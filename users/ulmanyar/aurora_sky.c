#include QMK_KEYBOARD_H
#include "aurora_sky.h"
#include <lib/lib8tion/lib8tion.h>

// Handle typing state 
static bool is_typing;

void set_aurora_typing_state(bool typing_state) {
    is_typing = typing_state;
}

bool get_aurora_typing_state() {
    return is_typing;
}

void render_aurora_sky() {
    // Handle OLED timeout
    static uint32_t timeout_timer = 0;
    if (get_aurora_typing_state()) {
        set_aurora_typing_state(false);
        timeout_timer = timer_read32();
    } else if (timer_elapsed32(timeout_timer) > OLED_TIMEOUT) {
        oled_off();
        return;
    }

    // Only progress animation if frame duration has passed
    static uint32_t animation_timer = 0;    // To keep track of framerate
    static uint8_t animation_counter = 0;   // To keep track of slow/fast animations
    if (timer_elapsed32(animation_timer) > AURORA_SKY_FRAME_DURATION) {
        animation_timer = timer_read32();
        animation_counter += 1;
    } else {
        return;
    }

    // Create the base canvas (sky, trees) without aurora
    // clang-format off
    static const char PROGMEM aurora_base_canvas[AURORA_CANVAS_SIZE] = {
        // 'aurora_blank', 32x128px
        0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x80, 
        0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x80, 0x70, 0x0c, 0xf0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
        0x00, 0xfc, 0x03, 0x00, 0xc8, 0x72, 0xcf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1c, 0xe0, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x06, 0xf8, 0x00, 0x00, 0x00, 0x00, 
        0xff, 0x00, 0x10, 0x12, 0xc9, 0xf0, 0xcf, 0xb4, 0x7f, 0x80, 0xe0, 0x1e, 0x01, 0x40, 0x65, 0x5e, 0xe0, 0x00, 0x00, 0xf0, 0x0c, 0xf0, 0x00, 0x80, 0x7e, 0x01, 0x80, 0x93, 0xfc, 0xc0, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x89, 0x18, 0x2c, 0x46, 0x00, 0x07, 0x21, 0x10, 0x10, 0x80, 0x09, 0x13, 0x31, 0xbf, 0xff, 0x00, 0x08, 0x1a, 0xf7, 0x0f, 0x00, 0x00, 0x44, 0x45, 0x34, 0xbf, 0xb8, 0x00, 
        0x10, 0xf0, 0x08, 0xf4, 0x18, 0x11, 0xfc, 0x18, 0xfb, 0x0e, 0x10, 0xf8, 0x04, 0xf8, 0x10, 0x20, 0x18, 0x09, 0xff, 0x0c, 0xea, 0x1f, 0x28, 0x60, 0x30, 0xf8, 0x20, 0xc0, 0x42, 0x33, 0x21, 0x00
    };
    // clang-format on
    static aurora_params lower_aurora = {
        .k = AURORA_UPPER_SLOPE,
        .T = AURORA_UPPER_PERIOD,
        .A_r = AURORA_UPPER_AMPLITUDE_RATE,
        .A = AURORA_UPPER_AMPLITUDE,
        .phi = 0,   // Used as internal state
        .x0 = AURORA_UPPER_START_X,
        .y0 = AURORA_UPPER_START_Y,
    };
    static aurora_params upper_aurora = {
        .k = AURORA_LOWER_SLOPE,
        .T = AURORA_LOWER_PERIOD,
        .A_r = AURORA_LOWER_AMPLITUDE_RATE,
        .A = AURORA_LOWER_AMPLITUDE,
        .phi = 0,   // Used as internal state
        .x0 = AURORA_LOWER_START_X,
        .y0 = AURORA_LOWER_START_Y,
    };

    // Copy base canvas to be filled with aurorae
    static char PROGMEM aurora_canvas[AURORA_CANVAS_SIZE];
    memcpy(aurora_canvas, aurora_base_canvas, AURORA_CANVAS_SIZE);
    generate_aurora(&lower_aurora, aurora_canvas);
    generate_aurora(&upper_aurora, aurora_canvas);
    oled_write_raw_P(aurora_canvas, AURORA_CANVAS_SIZE);
}


void generate_aurora(aurora_params *aurora, char canvas[]) {
    // Initialize aurora segment
    aurora_segment current_segment;
    uint8_t x_start = aurora->x0;// + (random8() % 3);   // TODO: Add randomisation
    uint8_t y_start = aurora->y0;// + (random8() % 3);   // TODO: Add randomisation

    // Update phase offset
    aurora->phi += AURORA_PHASE_MODIFIER * random8_min_max(2,4);

    for (uint8_t x = 0; x < AURORA_WIDTH - x_start; x++) {
        uint8_t y = y_start
            + x * (sin8(32 * (x / aurora->T) - aurora->phi) - 128) / aurora->A_r / 32
            - x * aurora->k;

        // TODO: Add borders to parameters/MACRO?
        if (y % 2 == 0) {
            current_segment.y_lower = y + 2;    // TODO: Add randomisation
            current_segment.y_upper = y - 2;    // TODO: Add randomisation
            // current_segment.y_lower = y + random8_min_max(0,1);
            // current_segment.y_upper = y - random8_min_max(2, max(3, aurora->A * x * 4 / aurora->A_r / 3));
        } else {
            current_segment.y_lower = y + 2;    // TODO: Add randomisation
            current_segment.y_upper = y - 2;    // TODO: Add randomisation
            // current_segment.y_lower = y + random8_min_max(1,3);
            // current_segment.y_upper = y - random8_min_max(2, aurora->A + x * 4 / aurora->A_r);
        }
        // Set current_segment x value
        current_segment.x = x + x_start;

        // Draw the current segment onto the canvas
        draw_aurora_on_canvas(&current_segment, canvas);
    }
    
}

void draw_aurora_on_canvas(aurora_segment *segment, char canvas[]) {
    // Invalid segment, don't draw anything
    if (segment->y_upper > segment->y_lower) {
        return;
    }

    // Get byte for upper and lower segment
    uint16_t byte_upper = segment->y_upper / 8 * AURORA_WIDTH + segment->x;
    uint16_t byte_lower = segment->y_lower / 8 * AURORA_WIDTH + segment->x;
    uint8_t y_local = segment->y_upper % 8;

    while (byte_upper < byte_lower) {
        // Draw upper to end of current byte
        canvas[byte_upper] |= ((uint8_t) ~0U << y_local);
        // Increment upper to next byte below
        y_local = 0;
        byte_upper += AURORA_WIDTH;
        // TODO: Add checks to min/max values
    }
    // Draw in last byte
    canvas[byte_upper] |= ((uint8_t) ~0U >> (8-(segment->y_lower % 8))) & ((uint8_t) ~0U << y_local);
}